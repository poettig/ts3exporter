package serverquery

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"
)

const structTagKey = "sq"

var escaping = map[string]string{
	"/":  `\/`,
	" ":  `\s`,
	"|":  `\p`,
	"\a": `\a`,
	"\b": `\b`,
	"\f": `\f`,
	"\n": `\n`,
	"\r": `\r`,
	"\t": `\t`,
	"\v": `\v`,
}

// Result contains both the raw result string generated by the serverquery command and a parsed list of items.
// Every item in the list will be parsed
type Result struct {
	Raw   string
	Items []Parsed
}

// Parsed is a parsed item of a server query command response. Since this type supports all TS3 ServerQuery commands,
// the key and value are both strings. If you expect a number, the parsing of the value is up to the consumer.
type Parsed map[string]string

// Parse parses a raw ts3 server query protocol answer string into a usable go struct
func Parse(in string) (Result, error) {
	r := Result{
		Raw: in,
	}
	var items []Parsed
	rawItems := strings.Split(in, "|")
	for _, rawItem := range rawItems {
		item := make(Parsed)
		elements := strings.Split(rawItem, " ")
		for _, element := range elements {
			parts := strings.SplitN(element, "=", 2)
			var value string
			if len(parts) == 2 {
				value = unescape(parts[1])
			}
			item[parts[0]] = value
		}
		items = append(items, item)
	}
	r.Items = items
	return r, nil
}

// unescape returns an unescaped string
func unescape(in string) string {
	for key, value := range escaping {
		in = strings.ReplaceAll(in, value, key)
	}
	return in
}

// escape returns an escaped string
// nolint: unused
func escape(in string) string {
	for key, value := range escaping {
		in = strings.ReplaceAll(in, key, value)
	}
	return in
}

// ReadInto reads the parsed value into the given interface.
// Any error is returned. In case of error, the given v may be in an inconsistent state.
func (p Parsed) ReadInto(v interface{}) error {
	ps := reflect.ValueOf(v)
	// struct
	s := ps.Elem()
	if s.Kind() != reflect.Struct {
		return fmt.Errorf("given type %T is not a struct", v)
	}
	st := s.Type()
	for i := 0; i < st.NumField(); i++ {
		field := st.Field(i)
		if protocolName, ok := field.Tag.Lookup(structTagKey); ok {
			stringValue := p[protocolName]
			if stringValue == "" {
				continue
			}
			switch field.Type.Kind() {
			case reflect.String:
				s.FieldByName(field.Name).SetString(stringValue)
			case reflect.Int:
				intValue, err := strconv.ParseInt(stringValue, 10, 64)
				if err != nil {
					return fmt.Errorf("failed to parse string %s(%s) to int: %w", stringValue, field.Name, err)
				}
				s.FieldByName(field.Name).SetInt(intValue)
			case reflect.Float32:
				fallthrough
			case reflect.Float64:
				float64Value, err := strconv.ParseFloat(stringValue, 64)
				if err != nil {
					return fmt.Errorf("failed to parse string %s(%s) to float64: %w", stringValue, field.Name, err)
				}
				s.FieldByName(field.Name).SetFloat(float64Value)
			default:
				return fmt.Errorf("unsupported field type %s for field %s", field.Type.Kind(), field.Name)
			}
		}
	}
	return nil
}
